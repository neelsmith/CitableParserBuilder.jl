var documenterSearchIndex = {"docs":
[{"location":"guide/parser/#Users'-guide:-the-CitableParser","page":"Users' guide: the CitableParser","title":"Users' guide: the CitableParser","text":"","category":"section"},{"location":"guide/parser/","page":"Users' guide: the CitableParser","title":"Users' guide: the CitableParser","text":"The CitableParser is an abstract type with associated functions for analyzing individual tokens or lists of tokens.","category":"page"},{"location":"guide/parsers/#Examples-of-CitableParsers","page":"Examples of CitableParsers","title":"Examples of CitableParsers","text":"","category":"section"},{"location":"guide/parsers/","page":"Examples of CitableParsers","title":"Examples of CitableParsers","text":"The following Julia modules implement the CitableParser abstraction:","category":"page"},{"location":"guide/parsers/","page":"Examples of CitableParsers","title":"Examples of CitableParsers","text":"Kanones: ancient Greek. Github.\nTabulae: Latin. Docs. Github.\nLycian: Lycian. Docs.Github.","category":"page"},{"location":"guide/corpora/#Analyzing-text-corpora","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"","category":"section"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"Use an OrthographicSystem together with a CitableParser to analyze a full text corpus.  Implementations of the OrthographicSystem abstraction can parse a citable text corpus into a list of tokens.  Since CitableParsers can parse citable tokens, the analyzecorpus function trivially composes these functions to create a list of analyses for each token in a citable corpus.","category":"page"},{"location":"guide/corpora/#Example-of-analyzing-a-citable-text-corpus","page":"Analyzing text corpora","title":"Example of analyzing a citable text corpus","text":"","category":"section"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"Let's instantiate a dummy parser that just analyzes all tokens the same way.","category":"page"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"using CitableParserBuilder\nstruct FakeParser <: CitableParser\n    stringparser\nend\nfunction fakestringparser(token, data...) \n    # Returns only nothing values no matter\n    # what the token is\n    [\n        Analysis(\n        token,\n        LexemeUrn(\"fakeparser.nothing\"),\n        FormUrn(\"fakeparser.nothing\"),\n        StemUrn(\"fakeparser.nothing\"),\n        RuleUrn(\"fakeparser.nothing\")\n    )\n    ]\nend\nfp = FakeParser(fakestringparser)\ntypeof(fp)\n\n# output\n\nFakeParser","category":"page"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"Now let's create a text corpus.","category":"page"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"using CitableText, CitableCorpus\n mred = CitableTextCorpus([\n        CitableNode(CtsUrn(\"urn:cts:docstrings:mred.themesong:1\"),\"A horse is a horse, of course, of course,\"),\n        CitableNode(CtsUrn(\"urn:cts:docstrings:mred.themesong:2\"),\"And no one can talk to a horse of course,\"),\n        CitableNode(CtsUrn(\"urn:cts:docstrings:mred.themesong:3\"),\"That is, of course, unless the horse is the famous Mr. Ed.\"),\n])\ntypeof(mred)\n\n# output\n\nCitableTextCorpus","category":"page"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"We'll use the Orthography module's sample simpleAscii orthography.","category":"page"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"using Orthography\nanalyses = analyzecorpus(fp, simpleAscii(), mred)\nanalyses |> length\n\n# output\n\n31","category":"page"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"Each analysis pairs a CitableNode with a list of Analysis objects.","category":"page"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"tkn1 = analyses[1]\ntkn1[1]\n\n# output\n\nCitableNode(CtsUrn(\"urn:cts:docstrings:mred.themesong:1.1\"), \"A\")","category":"page"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"analysisvector = tkn1[2]\nlength(analysisvector)\n\n# output\n\n1","category":"page"},{"location":"guide/corpora/","page":"Analyzing text corpora","title":"Analyzing text corpora","text":"analysisvector[1]\n\n# output\n\nAnalysis(\"A\", LexemeUrn(\"fakeparser\", \"nothing\"), FormUrn(\"fakeparser\", \"nothing\"), StemUrn(\"fakeparser\", \"nothing\"), RuleUrn(\"fakeparser\", \"nothing\"))","category":"page"},{"location":"#CitableParserBuilder:-overview","page":"Overview","title":"CitableParserBuilder:  overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The CitableParserBuilder module offers common functions and data structures for working with citable morphological analyses of citable texts.  ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"At the center of the module are the abstract CitableParser, and the concrete Analysis type. Functions for morphological parsing use a CitableParser to operate either on string values for individual tokens, or on passages of text citable with CTS URNs at the token level.  Parsing a token returns a (possibly empty) list of Analysis objects, which express the results of the parse with URN values.","category":"page"},{"location":"#Shared-structures:-the-Analysis","page":"Overview","title":"Shared structures: the Analysis","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Every analysis of a token identifies a valid pairing of a lexeme and a form for the token.  The Analysis further supports a typical model of computational morphological analysis that crosses a lexicon of stems with a set of inflectional patterns to create a comprehensive set of recognized forms. The stem and rule of an Analysis explain how the analysis' lexeme and form were arrived at.  The structure of the Analysis therefore consists of four URN values:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"the lexeme\nthe morphological form\nthe stem used to arrive at the analysis\nthe inflectional rule used to arrive at the analysis","category":"page"},{"location":"#Shared-functions-for-parsing:-the-CitableParser-abstraction","page":"Overview","title":"Shared functions for parsing: the CitableParser abstraction","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Types implementing the CitableParser abstraction must have a member function named stringparser(tkn::AbstractString) that returns a list of Analysis objects.  That makes possible a parsetoken function with the following signature:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"parsetoken(p::T, t::AbstractString) where {T <: CitableParser}","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"parsetoken simply invokes p.stringparser(t) to parse the string value for a single token.  With this in place, the CitableParserBuilder can include concrete implementations of the following functions:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"parsetoken: parse a string value\nparsewordlist: parse a list of string values\nparselistfromfile: parse a list of string values in a local file\nparselistfromurl: parse a list of string values from the contents of a URL\nparsenode: parse the text component of a CitableNode as a single token\nparsecorpus: parse the text components of all nodes in a CitableCorpus as individual tokens","category":"page"},{"location":"#Utilities","page":"Overview","title":"Utilities","text":"","category":"section"},{"location":"#Abbreviated-URN-values","page":"Overview","title":"Abbreviated URN values","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The AbbreviatedUrn is an abstract type supporting an abbreviated notation for Cite2Urns. It allows you to work with objects uniquely identified by collection identifier and object identifier, when the collection is registered in a dictionary that can expand the collection identifier to a full Cite2Urn.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The modules implements the AbbrevatedUrn for each uniquely identified component of an Analysis:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"LexemeUrn\nFormUrn\nStemUrn\nRuleUrn","category":"page"},{"location":"#SFST-utilities","page":"Overview","title":"SFST utilities","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Kanones and Tabulae are Julia packages for building ancient Greek and Latin morphological parsers, respectively.  Both Kanones and Tabulae do their parsing behind the scenes using finite state transducers built with the Stuttgart Finite State Transducer toolkit.  To facilitate this work, CitableParserBuilder includes utilities for transcoding string values to and from URN values and expressions in SFST-PL, the programmning language of the Stuttgart Finite State Transducer tooolkit.","category":"page"},{"location":"#CEX-utilities","page":"Overview","title":"CEX utilities","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The module supports export of parsing results in CEX format.","category":"page"},{"location":"man/#API-documentation","page":"API documentation","title":"API documentation","text":"","category":"section"},{"location":"man/#Structures","page":"API documentation","title":"Structures","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"AbbreviatedUrn\nStem\nRule\nAnalysis\nStemUrn\nRuleUrn\nLexemeUrn\nFormUrn\nAnalyzedToken","category":"page"},{"location":"man/#CitableParserBuilder.AbbreviatedUrn","page":"API documentation","title":"CitableParserBuilder.AbbreviatedUrn","text":"Short form of a Cite2Urn containing only collection and object ID.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.Stem","page":"API documentation","title":"CitableParserBuilder.Stem","text":"Supertype of all concrete Stem structures.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.Rule","page":"API documentation","title":"CitableParserBuilder.Rule","text":"Supertype of all concrete Rule structures.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.Analysis","page":"API documentation","title":"CitableParserBuilder.Analysis","text":"A citable morphological analysis.\n\nAn Analysis has five members: a token string value, and four abbreviated URNs, one each for the lexeme, form, rule and stem.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.StemUrn","page":"API documentation","title":"CitableParserBuilder.StemUrn","text":"Abbreviated URN for a morphological stem.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.RuleUrn","page":"API documentation","title":"CitableParserBuilder.RuleUrn","text":"Abbreviated URN for rule.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.LexemeUrn","page":"API documentation","title":"CitableParserBuilder.LexemeUrn","text":"Abbreviated URN for a lexeme.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.FormUrn","page":"API documentation","title":"CitableParserBuilder.FormUrn","text":"Abbreviated URN for a morphological form.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.AnalyzedToken","page":"API documentation","title":"CitableParserBuilder.AnalyzedToken","text":"Morphological analyses for a token identified by CTS URN.\n\n\n\n\n\n","category":"type"},{"location":"man/#Parsing","page":"API documentation","title":"Parsing","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"parsetoken\nparsewordlist\nparselistfromfile\nparselistfromurl\nparsenode\nparsecorpus","category":"page"},{"location":"man/#CitableParserBuilder.parsetoken","page":"API documentation","title":"CitableParserBuilder.parsetoken","text":"Required function to parse a single token with a CitableParser.\n\nparsetoken(p, t, data)\n\n\nShould return a (possibly empty) Vector of Analyses.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.parsewordlist","page":"API documentation","title":"CitableParserBuilder.parsewordlist","text":"Parse a list of tokens with a CitableParser.\n\nparsewordlist(p, tokens, data)\n\n\nShould return a (possibly empty) Vector of Analyses.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.parselistfromfile","page":"API documentation","title":"CitableParserBuilder.parselistfromfile","text":"Parse a list of tokens in a file with a CitableParser.\n\nparselistfromfile(p, f)\nparselistfromfile(p, f, delim, data)\n\n\nShould return pairings of tokens with a (possibly empty) Vector of Analyses.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.parselistfromurl","page":"API documentation","title":"CitableParserBuilder.parselistfromurl","text":"Parse a list of tokens at a given url with a CitableParser.\n\nShould return pairings of tokens with a (possibly empty) Vector of Analyses.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.parsenode","page":"API documentation","title":"CitableParserBuilder.parsenode","text":"Parse a CitableNode with text for a single token with a CitableParser.\n\nparsenode(p, cn, data)\n\n\nShould return a pairing of the CitableNode with a list of analyses.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.parsecorpus","page":"API documentation","title":"CitableParserBuilder.parsecorpus","text":"Use a CitableParser to parse a CitableTextCorpus with each citable node containing containg a single token.\n\nparsecorpus(p, c, data)\n\n\nShould return a list of pairings of a CitableNode with a list of analyses.\n\n\n\n\n\n","category":"function"},{"location":"man/#Creating-an-analyzed-corpus","page":"API documentation","title":"Creating an analyzed corpus","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"analyzecorpus","category":"page"},{"location":"man/#CitableParserBuilder.analyzecorpus","page":"API documentation","title":"CitableParserBuilder.analyzecorpus","text":"Pair each lexical node in a token-level edition with a list of Analysis objects for that token.\n\nanalyzecorpus(parser, ortho, c)\n\n\n\n\n\n\n","category":"function"},{"location":"man/#Working-with-AbbreviatedUrns","page":"API documentation","title":"Working with AbbreviatedUrns","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"abbreviate\nexpand\nfstsafe\nabbreviation","category":"page"},{"location":"man/#CitableParserBuilder.abbreviate","page":"API documentation","title":"CitableParserBuilder.abbreviate","text":"abbreviate(urn::Cite2Urn)\n\nConstructs an AbbreviatedUrn string from a Cite2Urn.\n\nExample:\n\njulia> abbreviate(Cite2Urn(\"urn:cite2:kanones:lsj.v1:n123\"))\n\"lsj.n123\"\n\nExample: a pipeline abbreviating a Cite2Urn and forming a LexemeUrn from the abbreviated string value.\n\njulia> Cite2Urn(\"urn:cite2:kanones:lsj.v1:n123\") |> abbreviate |> LexemeUrn\nLexemeUrn(\"lsj\", \"n123\")\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.expand","page":"API documentation","title":"CitableParserBuilder.expand","text":"expand(au::AbbreviatedUrn, registry::Dict)\n\nConstructs a Cite2Urn from an AbbreviatedUrn and a dictionary mapping collection identifiers in  AbbreviatedUrns's to full Cite2Urns for a versioned collection.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.fstsafe","page":"API documentation","title":"CitableParserBuilder.fstsafe","text":"Compose SFST representation of an AbbreviatedUrn.\n\nfstsafe(au)\n\n\nExample:\n\njulia> LexemeUrn(\"lexicon.lex123\") |> fstsafe\n\"<u>lexicon\\.lex123</u>\"\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.abbreviation","page":"API documentation","title":"CitableParserBuilder.abbreviation","text":"Create string abbreviation for an AbbreviatedUrn.\n\nabbreviation(au)\n\n\n\n\n\n\n","category":"function"},{"location":"man/#Working-with-Stems-and-Rules","page":"API documentation","title":"Working with Stems and Rules","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"CitableParserBuilder.lexeme\nCitableParserBuilder.id\nCitableParserBuilder.inflectiontype","category":"page"},{"location":"man/#CitableParserBuilder.lexeme","page":"API documentation","title":"CitableParserBuilder.lexeme","text":"Function required to get lexeme  value of a Stem implementation.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.id","page":"API documentation","title":"CitableParserBuilder.id","text":"Function required to get ID value of a Stem implementation.\n\n\n\n\n\nFunction required to get ID value of a Rule implementation.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.inflectiontype","page":"API documentation","title":"CitableParserBuilder.inflectiontype","text":"Function required to get string value for inflection class of a Stem implementation.\n\n\n\n\n\nFunction required to get string value for inflection class of a Rule implementation.\n\n\n\n\n\n","category":"function"},{"location":"man/#Reading-FST-output-from-a-file","page":"API documentation","title":"Reading FST output from a file","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"readfst","category":"page"},{"location":"man/#CitableParserBuilder.readfst","page":"API documentation","title":"CitableParserBuilder.readfst","text":"Read SFST output from file, and parse into a dictionary of tokens -> (possibly empty) array of SFST strings.\n\nreadfst(f)\n\n\nParameters\n\nf Name of file to read in.\n\n\n\n\n\n","category":"function"},{"location":"man/#Serialization","page":"API documentation","title":"Serialization","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"cex","category":"page"},{"location":"man/#CitableParserBuilder.cex","page":"API documentation","title":"CitableParserBuilder.cex","text":"Serialize an Analaysis as delimted text.\n\ncex(a)\ncex(a, delim)\n\n\n\n\n\n\nSerialize an Analaysis as delimited text.\n\ncex(tkn; delim, delim2, delim3)\n\n\n\n\n\n\nCompose delimited text representation for a  map of tokens to a vector of analyses.\n\ncex(prs)\n\n\n\n\n\n\n","category":"function"},{"location":"guide/analyses/#User's-guide:-working-with-analyses","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"","category":"section"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"The Analysis type represents the results of a purely morphological analyis.","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"The AnalyzedToken type associates Analysis objects with a token in a specific context.","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"Notable points:","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"the AnalyzedToken should cite the text at the level of individual token, normally by expanding the citation hierarchy on level to identify tokens within a canonically citable unit\nthe Vector of analyses associated with an AnalyzedToken may be empty. This means that no analyis was found for the given token.\nthe string value for the token in an AnalyzedToken  represents the string as it appears in the cited text.  The string for the token in an Analysis represents the string that was analyzed.  These two values may or may not be identical.  If the token was normalized in some way before analysis (e.g., adjusting case or accent) they may differ.","category":"page"},{"location":"guide/analyses/#Abbreviated-URNs","page":"User's guide: working with analyses","title":"Abbreviated URNs","text":"","category":"section"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"The package defines an abstract AbbreviatedUrn structure, with four implementations:  the LexemeUrn, FormUrn, StemUrn and RuleUrn structures.","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"An AbbreviatedUrn has a collection identifier, and an object identifier.  You can construct an AbbreviatedUrn from a dot-delimited string.","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"using CitableParserBuilder\nlexurn = LexemeUrn(\"lsj.n125\")\nlexurn.collection\n\n# output\n\n\"lsj\"","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"lexurn.objectid\n\n# output\n\n\"n125\"","category":"page"},{"location":"guide/analyses/#Abbreviated-URNs-and-Cite2Urns","page":"User's guide: working with analyses","title":"Abbreviated URNs and Cite2Urns","text":"","category":"section"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"You can use the abbreviate function to create an abbreviation string from a Cite2Urn using the collection identifier and the object identifer of the Cite2Urn.","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"using CitableObject\nconjunctionurn = Cite2Urn(\"urn:cite2:kanones:morphforms.v1:1000000001\")\nabbreviate(conjunctionurn)\n\n# output\n\n\"morphforms.1000000001\"","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"Of course you can use this string in turn to instantiate an AbbreviatedUrn structure.","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"formurn = abbreviate(conjunctionurn) |> FormUrn\ntypeof(formurn)\n\n# output\n\nFormUrn","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"formurn.objectid\n\n# output\n\n\"1000000001\"","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"To convert an AbbreviatedUrn to a full Cite2Urn, give the expand function a dictionary mapping collection identifiers to full URN strings for the collection","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"registry = Dict(\n    \"morphforms\" => \"urn:cite2:kanones:morphforms.v1:\"\n)\nexpanded = expand(formurn, registry)\ntypeof(expanded)\n\n# output\n\nCite2Urn","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"expanded.urn\n\n# output\n\n\"urn:cite2:kanones:morphforms.v1:1000000001\"","category":"page"},{"location":"guide/analyses/#Abbreviated-URNs-and-SFST-PL","page":"User's guide: working with analyses","title":"Abbreviated URNs and SFST-PL","text":"","category":"section"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"The fstsafe function composes an expression in SFST-PL for AbbrevatiedUrns.  It assumes that your SFST alphabet includes tokens <u> and </u> to mark beginning and ending boundaries of URN values. It escapes characters that are valid in URNs but reserved in the Stuttgart FST toolkit.  ","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"rule = RuleUrn(\"nouninfl.h_hs1\")\nfst = fstsafe(rule)\n\n# output\n\n\"<u>nouninfl\\\\.h\\\\_hs1</u>\"","category":"page"},{"location":"guide/analyses/","page":"User's guide: working with analyses","title":"User's guide: working with analyses","text":"","category":"page"}]
}
