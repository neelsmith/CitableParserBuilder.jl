var documenterSearchIndex = {"docs":
[{"location":"guide/parser/#The-CitableParser","page":"The CitableParser","title":"The CitableParser","text":"","category":"section"},{"location":"guide/parser/","page":"The CitableParser","title":"The CitableParser","text":"The CitableParser is an abstract type with associated functions for analyzing individual tokens or lists of tokens.","category":"page"},{"location":"guide/guide/#User's-guide","page":"User's guide","title":"User's guide","text":"","category":"section"},{"location":"guide/guide/#The-Analysis-type","page":"User's guide","title":"The Analysis type","text":"","category":"section"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"Each individual Analysis associates four features, identified by URN, with a string value for a token:","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"the lexeme \nthe form\nthe stem\nthe inflectional rule","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"For a morphologically ambiguous token, there will be multiple valid Analysis objects with the same string value.","category":"page"},{"location":"guide/guide/#Stems-and-Rules","page":"User's guide","title":"Stems and Rules","text":"","category":"section"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"The CitableParserBuilder assumes a typical model of computational morphological analysis that crosses a lexicon of stems with a set of inflectional patterns to create a comprehensive set of recognized forms.  The stem and rule  of an Analysis  explain how the analysis' lexeme and form were arrived at.","category":"page"},{"location":"guide/guide/#Abbreviated-URNs","page":"User's guide","title":"Abbreviated URNs","text":"","category":"section"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"The package defines an abstract AbbreviatedUrn structure, with four implementations:  the LexemeUrn, FormUrn, StemUrn and RuleUrn structures.","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"An AbbreviatedUrn has a collection identifier, and an object identifier.  You can construct an AbbreviatedUrn from a dot-delimited string.","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"using CitableParserBuilder\nlexurn = LexemeUrn(\"lsj.n125\")\nlexurn.collection\n\n# output\n\n\"lsj\"","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"lexurn.objectid\n\n# output\n\n\"n125\"","category":"page"},{"location":"guide/guide/#Abbreviated-URNs-and-Cite2Urns","page":"User's guide","title":"Abbreviated URNs and Cite2Urns","text":"","category":"section"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"You can use the abbreviate function to create an abbreviation string from a Cite2Urn using the collection identifier and the object identifer of the Cite2Urn.","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"using CitableObject\nconjunctionurn = Cite2Urn(\"urn:cite2:kanones:morphforms.v1:1000000001\")\nabbreviate(conjunctionurn)\n\n# output\n\n\"morphforms.1000000001\"","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"Of course you can use this string in turn to instantiate an AbbreviatedUrn structure.","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"formurn = abbreviate(conjunctionurn) |> FormUrn\nformurn.objectid\n\n# output\n\n\"1000000001\"","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"To convert an AbbreviatedUrn to a full Cite2Urn, give the expand function a dictionary mapping collection identifiers to full URN strings for the collection","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"registry = Dict(\n    \"morphforms\" => \"urn:cite2:kanones:morphforms.v1:\"\n)\nexpanded = expand(formurn, registry)\nexpanded.urn\n\n# output\n\n\"urn:cite2:kanones:morphforms.v1:1000000001\"","category":"page"},{"location":"guide/guide/#Abbreviated-URNs-and-SFST-PL","page":"User's guide","title":"Abbreviated URNs and SFST-PL","text":"","category":"section"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"Some characters that are valid in URNs are reserved in the Stuttgart FST toolkit.  The fstsafe function composes an expression in SFST-PL for AbbrevatiedUrns.","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"rule = RuleUrn(\"nouninfl.h_hs1\")\nfst = fstsafe(rule)\n\n# output\n\n\"<u>nouninfl\\\\.h\\\\_hs1</u>\"","category":"page"},{"location":"guide/guide/","page":"User's guide","title":"User's guide","text":"","category":"page"},{"location":"#CitableParserBuilder","page":"Home","title":"CitableParserBuilder","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The CitableParserBuilder package offers common functions and structures used by the Kanones and Tabulae packages for building ancient Greek and Latin morphological parsers, respectively.  Since both Kanones and Tabulae build finite state transducers with the Stuttgart Finite State Transducer, CitableParserBuilder includes utilities for transcoding string values to and from URN values and SFST-PL expressions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nKanones.jl and Tabulae.jl are not yet registered packages.","category":"page"},{"location":"#Shared-structures","page":"Home","title":"Shared structures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Analysis.  URN values define the four components of an Analysis:\nthe lexeme\nthe morphological form\nthe stem used to arrive at the analysis\nthe inflectional rule used to arrive at the analysis\nStem and Rule.  Abstract types for specific stem and rule types identified by AbbreviatedUrns.  Stems     \nAbbreviatedUrn.  An abstract type supporting an abbreviated notation for Cite2Urns.  The package includes implementations of the AbbrevatedUrn for each uniquely identified component of an Analysis:\nLexemeUrn\nFormUrn\nStemUrn\nRuleUrn","category":"page"},{"location":"man/#API-documentation","page":"API documentation","title":"API documentation","text":"","category":"section"},{"location":"man/#Structures","page":"API documentation","title":"Structures","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"AbbreviatedUrn\nStem\nRule\nAnalysis\nStemUrn\nRuleUrn\nLexemeUrn\nFormUrn\nAnalyzedToken","category":"page"},{"location":"man/#CitableParserBuilder.AbbreviatedUrn","page":"API documentation","title":"CitableParserBuilder.AbbreviatedUrn","text":"Short form of a Cite2Urn containing only collection and object ID.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.Stem","page":"API documentation","title":"CitableParserBuilder.Stem","text":"Supertype of all concrete Stem structures.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.Rule","page":"API documentation","title":"CitableParserBuilder.Rule","text":"Supertype of all concrete Rule structures.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.Analysis","page":"API documentation","title":"CitableParserBuilder.Analysis","text":"A citable morphological analysis.\n\nAn Analysis has five members: a token string value, and four abbreviated URNs, one each for the lexeme, form, rule and stem.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.StemUrn","page":"API documentation","title":"CitableParserBuilder.StemUrn","text":"Abbreviated URN for a morphological stem.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.RuleUrn","page":"API documentation","title":"CitableParserBuilder.RuleUrn","text":"Abbreviated URN for rule.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.LexemeUrn","page":"API documentation","title":"CitableParserBuilder.LexemeUrn","text":"Abbreviated URN for a lexeme.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.FormUrn","page":"API documentation","title":"CitableParserBuilder.FormUrn","text":"Abbreviated URN for a morphological form.\n\n\n\n\n\n","category":"type"},{"location":"man/#CitableParserBuilder.AnalyzedToken","page":"API documentation","title":"CitableParserBuilder.AnalyzedToken","text":"Morphological analyses for a token identified by CTS URN.\n\n\n\n\n\n","category":"type"},{"location":"man/#Functions-for-working-with-AbbreviatedUrns","page":"API documentation","title":"Functions for working with AbbreviatedUrns","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"abbreviate\nexpand\nfstsafe\nabbreviation","category":"page"},{"location":"man/#CitableParserBuilder.abbreviate","page":"API documentation","title":"CitableParserBuilder.abbreviate","text":"abbreviate(urn::Cite2Urn)\n\nConstructs an AbbreviatedUrn string from a Cite2Urn.\n\nExample:\n\njulia> abbreviate(Cite2Urn(\"urn:cite2:kanones:lsj.v1:n123\"))\n\"lsj.n123\"\n\nExample: a pipeline abbreviating a Cite2Urn and forming a LexemeUrn from the abbreviated string value.\n\njulia> Cite2Urn(\"urn:cite2:kanones:lsj.v1:n123\") |> abbreviate |> LexemeUrn\nLexemeUrn(\"lsj\", \"n123\")\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.expand","page":"API documentation","title":"CitableParserBuilder.expand","text":"expand(au::AbbreviatedUrn, registry::Dict)\n\nConstructs a Cite2Urn from an AbbreviatedUrn and a dictionary mapping collection identifiers in  AbbreviatedUrns's to full Cite2Urns for a versioned collection.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.fstsafe","page":"API documentation","title":"CitableParserBuilder.fstsafe","text":"Compose SFST representation of an AbbreviatedUrn.\n\nfstsafe(au)\n\n\nExample:\n\njulia> LexemeUrn(\"lexicon.lex123\") |> fstsafe\n\"<u>lexicon\\.lex123</u>\"\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.abbreviation","page":"API documentation","title":"CitableParserBuilder.abbreviation","text":"Create string abbreviation for an AbbreviatedUrn.\n\nabbreviation(au)\n\n\n\n\n\n\n","category":"function"},{"location":"man/#Functions-for-working-with-Stems-and-Rules","page":"API documentation","title":"Functions for working with Stems and Rules","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"CitableParserBuilder.lexeme\nCitableParserBuilder.id\nCitableParserBuilder.inflectiontype","category":"page"},{"location":"man/#CitableParserBuilder.lexeme","page":"API documentation","title":"CitableParserBuilder.lexeme","text":"Function required to get lexeme  value of a Stem implementation.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.id","page":"API documentation","title":"CitableParserBuilder.id","text":"Function required to get ID value of a Stem implementation.\n\n\n\n\n\nFunction required to get ID value of a Rule implementation.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.inflectiontype","page":"API documentation","title":"CitableParserBuilder.inflectiontype","text":"Function required to get string value for inflection class of a Stem implementation.\n\n\n\n\n\nFunction required to get string value for inflection class of a Rule implementation.\n\n\n\n\n\n","category":"function"},{"location":"man/#Reading-FST-output-from-a-file","page":"API documentation","title":"Reading FST output from a file","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"readfst","category":"page"},{"location":"man/#CitableParserBuilder.readfst","page":"API documentation","title":"CitableParserBuilder.readfst","text":"Read SFST output from file, and parse into a dictionary of tokens -> (possibly empty) array of SFST strings.\n\nreadfst(f)\n\n\nParameters\n\nf Name of file to read in.\n\n\n\n\n\n","category":"function"},{"location":"man/#Parsers-and-analyses","page":"API documentation","title":"Parsers and analyses","text":"","category":"section"},{"location":"man/","page":"API documentation","title":"API documentation","text":"parsetoken\nparsewordlist\nparselistfromfile\nparselistfromurl\ncex","category":"page"},{"location":"man/#CitableParserBuilder.parsetoken","page":"API documentation","title":"CitableParserBuilder.parsetoken","text":"Required function to parse a single token with a CitableParser.\n\nparsetoken(p, t)\n\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.parsewordlist","page":"API documentation","title":"CitableParserBuilder.parsewordlist","text":"Required function to parse a list of tokens with a CitableParser.\n\nparsewordlist(p, v)\n\n\nShould return pairs of tokens with a (possibly empty) Vector of Analyses.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.parselistfromfile","page":"API documentation","title":"CitableParserBuilder.parselistfromfile","text":"Required function to parse a list of tokens in a file with a CitableParser.\n\nShould return pairs of tokens with a (possibly empty) Vector of Analyses.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.parselistfromurl","page":"API documentation","title":"CitableParserBuilder.parselistfromurl","text":"Required function to parse a list of tokens at a given url with a CitableParser.\n\nShould return pairs of tokens with a (possibly empty) Vector of Analyses.\n\n\n\n\n\n","category":"function"},{"location":"man/#CitableParserBuilder.cex","page":"API documentation","title":"CitableParserBuilder.cex","text":"Serialize an Analaysis as delimted text.\n\ncex(a)\ncex(a, delim)\n\n\n\n\n\n\nSerialize an Analaysis as delimited text.\n\ncex(tkn; delim, delim2, delim3)\n\n\n\n\n\n\nCompose delimited text representation for a  map of tokens to a vector of analyses.\n\ncex(prs)\n\n\n\n\n\n\n","category":"function"},{"location":"guide/analyses/#Working-with-analyses","page":"Working with analyses","title":"Working with analyses","text":"","category":"section"},{"location":"guide/analyses/","page":"Working with analyses","title":"Working with analyses","text":"The Analysis type represents the results of a purely morphological analyis.","category":"page"},{"location":"guide/analyses/","page":"Working with analyses","title":"Working with analyses","text":"The AnalyzedToken type associates Analysis objects with a token in a specific context.","category":"page"},{"location":"guide/analyses/","page":"Working with analyses","title":"Working with analyses","text":"Notable points:","category":"page"},{"location":"guide/analyses/","page":"Working with analyses","title":"Working with analyses","text":"the AnalyzedToken should cite the text at the level of individual token, normally by expanding the citation hierarchy on level to identify tokens within a canonically citable unit\nthe Vector of analyses associated with an AnalyzedToken may be empty. This means that no analyis was found for the given token.\nthe string value for the token in an AnalyzedToken  represents the string as it appears in the cited text.  The string for the token in an Analysis represents the string that was analyzed.  These two values may or may not be identical.  If the token was normalized in some way before analysis (e.g., adjusting case or accent) they may differ.","category":"page"}]
}
